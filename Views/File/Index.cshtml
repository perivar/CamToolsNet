@using System.Globalization
@model DxfDocumentModel

@if (ViewData["Message"] != null)
{
    <div class="alert alert-success alert-dismissible" style="margin-top:20px">
        @ViewData["Message"]
    </div>
}	
    <div class="container">
        <div class="row pb-2">
            <input type="button" class="btn btn-primary btn-sm" title="MoveEqual" value="Move Equal Circles To Unique Layers" onclick="location.href='@Url.Action("CirclesToLayers", "File")'" />
        </div>

        <div class="row">
            <canvas id="myCanvas" width="800" height="400" class="border">
            </canvas>
        </div>
    </div>
                       
@section Scripts {
    <script>
        function draw(scale, translatePos){
            var canvas = document.getElementById("myCanvas");
            var context = canvas.getContext("2d");

            // clear canvas
            context.clearRect(0, 0, canvas.width, canvas.height);

            context.save();
            context.translate(translatePos.x, translatePos.y);
            context.scale(scale, scale);

            @if (Model != null) {            
                <text>       

                // circles
                context.beginPath(); // begin
                @foreach (var c in Model.Circles)
                {
                    <text>
                        var startAngle = 0;
                        var endAngle = 2 * Math.PI;
                        var x = @c.Center.X.ToString(CultureInfo.InvariantCulture);
                        var y = canvas.height - @c.Center.Y.ToString(CultureInfo.InvariantCulture);
                        var radius = @c.Radius.ToString("N", CultureInfo.InvariantCulture);
                        
                        context.moveTo(x + radius, y);
                        context.arc(x, y, radius, startAngle, endAngle, false);

                        context.font = '5px sans-serif';
                        context.fillText('' + radius*2, x+4, y+4);
                    </text>
                }
                context.closePath(); // end

                context.lineWidth = 0.3;
                context.strokeStyle = "#0000ff";
                context.stroke();

                // lines
                context.beginPath(); // begin
                @foreach (var l in Model.Lines)
                {
                    <text>
                        var startX = @l.StartPoint.X.ToString(CultureInfo.InvariantCulture);
                        var startY = canvas.height - @l.StartPoint.Y.ToString(CultureInfo.InvariantCulture);
                        var endX = @l.EndPoint.X.ToString(CultureInfo.InvariantCulture);
                        var endY = canvas.height - @l.EndPoint.Y.ToString(CultureInfo.InvariantCulture);
                        
                        context.moveTo(startX, startY);
                        context.lineTo(endX, endY);
                    </text>
                }
                context.closePath(); // end

                context.lineWidth = 0.3;
                context.strokeStyle = "#cc00ff";
                context.stroke();

                // arcs
                context.beginPath(); // begin
                @foreach (var a in Model.Arcs)
                {
                    <text>
                        var centerX = @a.Center.X.ToString(CultureInfo.InvariantCulture);
                        var centerY = @a.Center.Y.ToString(CultureInfo.InvariantCulture);
                        var radius = @a.Radius.ToString(CultureInfo.InvariantCulture);
                        var startAngle = @a.StartAngle.ToString(CultureInfo.InvariantCulture);
                        var endAngle = @a.EndAngle.ToString(CultureInfo.InvariantCulture);

                        var startX = (centerX + Math.cos(startAngle * Math.PI / 180) * radius);
                        var startY = (centerY + Math.sin(startAngle * Math.PI / 180) * radius);
                        var endX = (centerX + Math.cos(endAngle * Math.PI / 180) * radius);
                        var endY = (centerY + Math.sin(endAngle * Math.PI / 180) * radius);

                        @* since we are offsetting the y axis due to a different origin coordinate system, we have to also change direction *@
                        var isCounterClockwise = true;

                        context.moveTo(startX, canvas.height - startY);
                        context.arc(centerX, canvas.height - centerY, radius, startAngle * Math.PI / 180, endAngle * Math.PI / 180, isCounterClockwise);
                        context.moveTo(endX, canvas.height - endY);
                    </text>
                }
                context.closePath(); // end

                context.lineWidth = 0.3;
                context.strokeStyle = "#000000";
                context.stroke();

                // polylines
                context.beginPath(); // begin
                @foreach (var p in Model.Polylines)
                {
                    for (int i = 0; i < p.Vertexes.Count; i++)
                    {
                        var vertex = p.Vertexes[i];
                        <text>                            
                            var pointX = @vertex.Position.X.ToString(CultureInfo.InvariantCulture);
                            var pointY = @vertex.Position.Y.ToString(CultureInfo.InvariantCulture);
                            var prePointX = 0;
                            var prePointY = 0;
                            var bulge = 0;

                            @if (i == 0)
                            {   
                                <text>                               
                                context.moveTo(pointX, pointY);
                                </text>  
                            }
                            else {
                                <text> 
                                double angle = 4 * Math.atan(Math.abs(bulge)) / Math.PI * 180;
                                double length = Math.sqrt((pointX - prePointX) * (pointX - prePointX) + (pointY - prePointY) * (pointY - prePointY));
                                double radius = Math.abs(length / (2 * Math.sin(angle / 360 * Math.PI)));
                                context.arc(pointX, pointY, radius, 0, angle * Math.PI / 180, false);

                                prePointX = pointX;
                                prePointY = pointY;
                                </text>
                            }
                        </text>
                    }                    
                }
                context.closePath(); // end

                context.lineWidth = 0.3;
                context.strokeStyle = "#002266";
                context.stroke();


                </text>
            }

            context.restore();
        }

        window.onload = function(){
            var canvas = document.getElementById("myCanvas");

            var translatePos = {
                x: canvas.width / 2,
                y: canvas.height / 2
            };

            var scale = 1.0;
            var scaleMultiplier = 0.8;
            var startDragOffset = {};
            var mouseDown = false;

            // add event listeners to handle screen drag
            canvas.addEventListener("mousedown", function(evt){
                mouseDown = true;
                startDragOffset.x = evt.clientX - translatePos.x;
                startDragOffset.y = evt.clientY - translatePos.y;
            });

            canvas.addEventListener("mouseup", function(evt){
                mouseDown = false;
            });

            canvas.addEventListener("mouseover", function(evt){
                mouseDown = false;
            });

            canvas.addEventListener("mouseout", function(evt){
                mouseDown = false;
            });

            canvas.addEventListener("mousemove", function(evt){
                if (mouseDown) {
                    translatePos.x = evt.clientX - startDragOffset.x;
                    translatePos.y = evt.clientY - startDragOffset.y;
                    draw(scale, translatePos);
                }
            });
    
            var handleScroll = function(evt) {
                 // e is the mouse wheel event
                const x = evt.offsetX;
                const y = evt.offsetY;
                
                const amount = evt.wheelDelta > 0 ?  1.1 : 1 / 1.1; 

                scale *= amount;  // the new scale

                @* if (scale > 5) {
                    scale = 5;
                    amount = scale/5;
                } else if (scale < 0.5) {
                    scale = 0.5;
                    amount = scale*5;
                } *@

                // move the origin  
                translatePos.x = x - (x - translatePos.x) * amount;
                translatePos.y = y - (y - translatePos.y) * amount;
                
                draw(scale, translatePos);

                return evt.preventDefault() && false;
            };

            canvas.addEventListener('DOMMouseScroll',handleScroll,false);
            canvas.addEventListener('mousewheel',handleScroll,false);

            draw(scale, translatePos);
        };
    </script>
}